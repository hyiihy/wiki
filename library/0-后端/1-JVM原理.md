# <center>JVM原理</center>

## Java内存模型
![Java内存模型](assets/0/20171208102903.png)   
**程序计数器：**  
- 记录正在执行的虚拟机字节码指令的地址。
- 线程私有，生命周期与线程相同。
- 线程执行Native方法时，计数器的值为空。
- 没有内存溢出异常

**Java虚拟机栈：**  
- 用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。
  - 局部变量表：存储方法参数和方法内部定义的变量。大小也在编译时确定。
  - 操作数栈：用于存储各种字节码指令（比如：加操作、赋值元算等）。Android的操作数放在寄存器，速度快，移植性差。
  - 动态链接：指向运行时常量池中该栈帧所属方法的引用。
  - 方法返回地址。
- 线程私有，生命周期与线程相同。
- 每个线程一个栈，线程里每个方法一个栈帧，栈的大小和栈帧的大小在编译时就已经确定了。
  - 栈里方法太多（比如递归不收敛），将抛出StackOverflowError异常。
  - 栈太多（线程太多），虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

**本地方法栈：**  
跟Java虚拟机栈类似，只不过是用于执行Native方法（同一个线程中调用Native方法时会新建一个栈？），在HotSpot中没有本地方法栈。

**Java堆：**  
- 所有线程共享的一块内存区域，占整个JVM所管辖的内存最多。（物理上不一定连续）
- 存放所有的实例对象和数组。
- 垃圾回收主要在这里执行。

**方法区：**  
- 所有线程共享。
- 用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

**直接内存：**  
直接内存在JVM管辖的内存之外，直接从操作系统分配，不受Java堆大小限制。但是受本机内存大小及处理器寻址空间的限制，也会抛出OutOfMemoryError异常。在NIO编程中用到。

## Java类加载机制
类加载的过程包括了加载、验证、准备、解析、初始化五个阶段，其顺序为：  

在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定。  
同时，上述顺序为开始的顺序，而不是进行或者完成的顺序，这些阶段通常是交叉混合进行的。

**加载：**  
加载时JVM的任务：
1. 通过一个类的全限定名来获取其定义的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

## Java垃圾回收
